"""
Marketing Campaign Capsule Type

Extends QLCapsule for marketing campaign deliverables.
"""

from typing import Dict, List, Any, Optional
from datetime import datetime
from pydantic import BaseModel, Field

from src.common.models import QLCapsule
from src.agents.marketing.models import MarketingCampaign, MarketingContent


class MarketingCapsule(QLCapsule):
    """Specialized capsule for marketing campaigns"""
    
    capsule_type: str = "marketing-campaign"
    campaign_data: MarketingCampaign
    
    # Additional marketing-specific fields
    content_files: Dict[str, str] = Field(
        default_factory=dict,
        description="Mapping of content_id to file path"
    )
    
    scheduling_config: Dict[str, Any] = Field(
        default_factory=dict,
        description="Platform-specific scheduling configuration"
    )
    
    assets: Dict[str, List[str]] = Field(
        default_factory=lambda: {
            "images": [],
            "videos": [],
            "documents": []
        },
        description="Media assets for the campaign"
    )
    
    templates: Dict[str, str] = Field(
        default_factory=dict,
        description="Reusable templates extracted from campaign"
    )
    
    @property
    def summary(self) -> str:
        """Generate campaign summary"""
        return f"""Marketing Campaign: {self.campaign_data.objective.value}
Target Audience: {self.campaign_data.target_audience}
Duration: {self.campaign_data.duration_days} days
Content Pieces: {self.campaign_data.total_pieces}
Channels: {', '.join(c.value for c in self.campaign_data.channels_used)}"""

    def to_file_structure(self) -> Dict[str, str]:
        """Convert campaign to file structure for storage"""
        files = {
            "README.md": self._generate_readme(),
            "campaign.json": self.campaign_data.json(indent=2),
            "schedule.csv": self._generate_schedule_csv(),
            "content/": "",  # Directory marker
            "assets/": "",   # Directory marker
            "templates/": "" # Directory marker
        }
        
        # Add individual content files
        for content in self.campaign_data.content_pieces:
            filename = f"content/{content.channel.value}/{content.content_id}.md"
            files[filename] = self._format_content_file(content)
        
        # Add templates
        for name, template in self.templates.items():
            files[f"templates/{name}.md"] = template
        
        return files
    
    def _generate_readme(self) -> str:
        """Generate README for the campaign"""
        return f"""# {self.campaign_data.objective.value} Marketing Campaign

## Overview
{self.summary}

## Campaign Strategy
{self.campaign_data.strategy_summary}

## Content Calendar
See `schedule.csv` for detailed scheduling.

## Quick Start
1. Review content in `/content` directory
2. Upload assets from `/assets` to your platforms
3. Use scheduling tools to automate posting
4. Monitor performance with provided KPIs

## KPIs to Track
{self._format_kpis()}

## File Structure
```
.
├── README.md           # This file
├── campaign.json       # Complete campaign data
├── schedule.csv        # Content calendar
├── content/           # All content pieces
│   ├── twitter/       # Twitter content
│   ├── linkedin/      # LinkedIn content
│   └── ...           # Other channels
├── assets/           # Media assets
└── templates/        # Reusable templates
```

Generated by QuantumLayer Platform
"""
    
    def _generate_schedule_csv(self) -> str:
        """Generate CSV schedule for import into scheduling tools"""
        import csv
        import io
        
        output = io.StringIO()
        writer = csv.writer(output)
        
        # Header
        writer.writerow([
            "Date", "Time", "Channel", "Type", "Title",
            "Content Preview", "Hashtags", "Media", "Status"
        ])
        
        # Sort content by scheduled time
        sorted_content = sorted(
            self.campaign_data.content_pieces,
            key=lambda c: c.scheduled_time or datetime.now()
        )
        
        for content in sorted_content:
            scheduled = content.scheduled_time or datetime.now()
            writer.writerow([
                scheduled.strftime("%Y-%m-%d"),
                scheduled.strftime("%H:%M"),
                content.channel.value,
                content.type.value,
                content.title or "Untitled",
                content.content[:100] + "..." if len(content.content) > 100 else content.content,
                " ".join(content.hashtags),
                " ".join(content.media_urls),
                "Scheduled"
            ])
        
        return output.getvalue()
    
    def _format_content_file(self, content: MarketingContent) -> str:
        """Format individual content piece as markdown"""
        return f"""# {content.title or content.content_id}

**Type**: {content.type.value}  
**Channel**: {content.channel.value}  
**Tone**: {content.tone.value}  
**Scheduled**: {content.scheduled_time.strftime("%Y-%m-%d %H:%M") if content.scheduled_time else "Not scheduled"}

## Content

{content.content}

## Metadata

**Target Audience**: {content.target_audience}

**Keywords**: {', '.join(content.keywords)}

**Hashtags**: {' '.join(content.hashtags)}

**CTA**: {content.cta or "None"}

**Media URLs**: 
{chr(10).join(f'- {url}' for url in content.media_urls) if content.media_urls else "None"}

---
Generated by QuantumLayer Marketing System
"""
    
    def _format_kpis(self) -> str:
        """Format KPIs as markdown list"""
        kpi_lines = []
        for key, value in self.campaign_data.kpis.items():
            formatted_key = key.replace("_", " ").title()
            kpi_lines.append(f"- **{formatted_key}**: {value}")
        return '\n'.join(kpi_lines)
    
    def export_for_platform(self, platform: str) -> Dict[str, Any]:
        """Export campaign in platform-specific format"""
        
        if platform == "buffer":
            return self._export_buffer_format()
        elif platform == "hootsuite":
            return self._export_hootsuite_format()
        elif platform == "mailchimp":
            return self._export_mailchimp_format()
        else:
            # Generic format
            return {
                "campaign": self.campaign_data.dict(),
                "files": self.to_file_structure()
            }
    
    def _export_buffer_format(self) -> Dict[str, Any]:
        """Export in Buffer's expected format"""
        updates = []
        
        for content in self.campaign_data.content_pieces:
            if content.channel in [Channel.TWITTER, Channel.LINKEDIN]:
                updates.append({
                    "text": content.content,
                    "profile_ids": [],  # Would be filled with actual IDs
                    "scheduled_at": content.scheduled_time.isoformat() if content.scheduled_time else None,
                    "media": {
                        "link": content.media_urls[0] if content.media_urls else None
                    }
                })
        
        return {"updates": updates}
    
    def _export_hootsuite_format(self) -> Dict[str, Any]:
        """Export in Hootsuite's expected format"""
        messages = []
        
        for content in self.campaign_data.content_pieces:
            messages.append({
                "text": content.content,
                "socialProfileIds": [],  # Would be filled
                "scheduledSendTime": content.scheduled_time.isoformat() if content.scheduled_time else None,
                "tags": content.hashtags,
                "mediaUrls": content.media_urls
            })
        
        return {"messages": messages}
    
    def _export_mailchimp_format(self) -> Dict[str, Any]:
        """Export email campaigns for Mailchimp"""
        campaigns = []
        
        email_content = [
            c for c in self.campaign_data.content_pieces
            if c.channel == Channel.EMAIL
        ]
        
        for content in email_content:
            campaigns.append({
                "type": "regular",
                "settings": {
                    "subject_line": content.title or "Newsletter",
                    "preview_text": content.content[:150],
                    "title": content.content_id
                },
                "content": {
                    "html": f"<html><body>{content.content}</body></html>",
                    "plain_text": content.content
                }
            })
        
        return {"campaigns": campaigns}